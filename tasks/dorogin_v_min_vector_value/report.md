## Подсчёт минимального элемента вектора целых чисел

- Student: Дорогин Вадим Антонович, 3823Б1ПР3
- Technology: SEQ | MPI
- Variant: 4

## 1. Introduction

В данной работе были реализованы два подхода для поиска минимального значения элементов вектора, а именно последовательный SEQ и параллельный с использованием MPI.
Цель – придумать алгоритм поиска минимума и реализовать две его версии: последовательную и параллельную. Также проверить на производительность и работоспособность данные реализации на наборе тестов

## 2. Problem Statement

Задача – найти минимальные значения во входном векторе целых чисел.

Входные данные – целочисленный вектор `std::vector<int>` (тип `InType`).  
Выходные данные – одно число целое `int` (тип `OutType`), которое равняется минимальному элементу вектора.

Особенности обработки:

- Наличие минимум одного элемента в векторе, иначе происходит некорректный вход
- Элеметны могут быть положительными, отрицательными, а также иметь повторения.
- Если есть нескольких одинаковых минимальных значений, то результатом будет являться это значение, а не его индекс.

Ограничения:

- Ограничение доступной памятью и временем выполнения размера вектора
- Корректная обработка значений алгоритмом в диапозоне `int`.
- Параллельная реализация использует MPI и должна корректно выполняться при разном числе процессов.

## 3. Baseline Algorithm (Sequential)

Последовательный алгортим, базовый, использует один проход по вектору, а также он является линейным по времени: `O(N)`, где `N` – количество элементов.

Идея:

- Инициализировать минимум первым элементом вектора.
- Последовательно обходить оставшиеся элементы и обновлять минимум при нахождении меньшего значения.

Эквивалентная реализация реализована с помощью страндартного алгоритма `std::min_element`, он также выполняет один линейны проход по диапазону.

Псевдокод:

```pseudocode
if data.size() == 0:
  ошибка (некорректный вход)

min_val = data[0]
for i from 1 to data.size() - 1:
  if data[i] < min_val:
    min_val = data[i]

return min_val
```

Данный алгоритм используется в последовательной реализации `DoroginVMinVectorValueSEQ` (через `std::min_element`).

## 4. Parallelization Scheme (MPI)

В MPI‑версии задача имеет такой же вид – найти минимальное значение по всему вектору, но нужно использовать нескольких процессов.

Схема распараллеливания:

- Входной вектор весь хранится на нулевом процессе
- Данные распределяются от процесса 0 к остальным процессам: каждый процесс получает свою часть вектора
- Каждый процесс вычисляет локальный минимум по своей части данных
- Используется `MPI_Reduce` с операцией `MPI_MIN` для получения глобального минимума
- Результат рассылается всем процессам с помощью `MPI_Bcast`, чтобы во всех экземплярах задачи (`Task`) `GetOutput()` содержал один и тот же результат.

Логика параллельной версии:

```pseudocode
rank = MPI_Comm_rank(MPI_COMM_WORLD)
size = MPI_Comm_size(MPI_COMM_WORLD)

chunk_size = data.size() / size
remainder = data.size() % size
local_size = chunk_size + (rank < remainder ? 1 : 0)

if rank == 0:
  local_data = data[0:local_size]
  for dest from 1 to size-1:
    dest_size = chunk_size + (dest < remainder ? 1 : 0)
    MPI_Send(data[offset:offset+dest_size], dest)
    offset += dest_size
else:
  MPI_Recv(local_data, local_size, from rank 0)

local_min = min_element(local_data)
MPI_Reduce(&local_min, &global_min, MPI_MIN, 0)
MPI_Bcast(&global_min, 1, MPI_INT, 0, MPI_COMM_WORLD)

GetOutput() = global_min
```

Данный подход обеспечивает реальное распараллеливание вычислений: каждый процесс обрабатывает свою часть данных, что позволяет эффективно использовать несколько процессов.

## 5. Implementation Details

Структура каталога задачи:

```text
tasks/dorogin_v_min_vector_value/
├── common
│   └── include
│       └── common.hpp
├── mpi
│   ├── include
│   │   └── ops_mpi.hpp
│   └── src
│       └── ops_mpi.cpp
├── seq
│   ├── include
│   │   └── ops_seq.hpp
│   └── src
│       └── ops_seq.cpp
├── tests
│   ├── functional
│   │   └── main.cpp
│   └── performance
│       └── main.cpp
├── info.json
├── report.md
└── settings.json
```

Ключевые типы и классы:

- `InType = std::vector<int>` – входные данные.
- `OutType = int` – результат.
- `BaseTask = ppc::task::Task<InType, OutType>` – базовый шаблон задачи.
- `DoroginVMinVectorValueSEQ` – последовательная реализация.
- `DoroginVMinVectorValueMPI` – MPI‑реализация.

Основные методы (общие для обеих реализаций через наследование от `BaseTask`):

- `ValidationImpl()` – проверка корректности входных данных (вектор != nil).
- `PreProcessingImpl()` – подготовка данных (тривиальна).
- `RunImpl()` – основной алгоритм (поиск минимума).
- `PostProcessingImpl()` – финал

## 6. Experimental Setup

- CPU / RAM / OS: 12th Gen Intel(R) Core(TM) i7-1260U, 16GB, Windows 11 x64
- Toolchain: Microsoft Visual C++, Visual Studio Code 2019/2022, Release, Microsoft MPI 10.1.
- Environment: mpiexec -n N, MPI_COMM_WORLD.

Тестовые данные:

- Функциональные тесты:
  - Набор разных векторов имеющие небольшой и средний размера с положительными и отрицательными значениями.
  - Вектора с единственным элементом.
  - Вектора с несколькими одинаковыми минимальными значениями.
  - Вектора с минимумом в начале, в середине и в конце.
- Тесты производительности:
  - Большой вектор длиной с десятков миллионов элементов (`kSize = 50 000 000`), заполнен он случайными числами и явно устанавливается известный минимум.

## 7. Results and Discussion

### 7.1 Correctness

Проверка моих алогритмов проверяется с помощью набора func тестов(`tests/functional/main.cpp`), они генерируют известные тестовые векторы, вычисляют ожидаемый минимум с помощью алгоритма (`std::min_element`), а также сравнивают результат работы задач `DoroginVMinVectorValueSEQ` и `DoroginVMinVectorValueMPI` с ожидаемым значением.

Так же проверяется работа если на входе пустой вектор: валидация завершится с ошибкой, и тесты проверяют корректное срабатывание механизма `Validation()` в базовом классе `Task`.

На всех функциональных тестах результаты последовательной и MPI‑реализаций совпадают, расхождений нет.

### 7.2 Performance

Производительность оценивается с помощью perf теста (`tests/performance/main.cpp`), который:

- генерирует большой вектор целых чисел (`kSize = 50 000 000`);
- случайно заполняет его значениями из заданного диапазона;
- принудительно устанавливает известный минимум в одной из позиций;
- запускает задачу в различных режимах выполнения (SEQ, MPI) и измеряет время работы.

Замеры времени выполнения (в секундах) для задачи размером 50 000 000 элементов:

| Режим | Процессов | Время, сек | Ускорение | Эффективность |
| seq   | 1         | 0.2161     | 1.00      | N/A           |
| mpi   | 2         | 0.1179     | 1.83      | 91.5%         |
| mpi   | 4         | 0.1335     | 1.62      | 40.5%         |
| mpi   | 6         | 0.1446     | 1.49      | 24.8%         |

Для этой задачи поиск минимума имеет линейную сложность, и выигрыши от MPI‑распараллеливания зависят от конкретной реализации MPI‑среды, расходов коммуникаций и размера начальных данных.  
На больших размерах входа время работы для последовательной и для MPI версии время работы вполне приемлемо при этом MPI версия в этой реализации 
применяет распределение данных по процессам, каждый процесс обрабатывает свою часть данных, что обеспечивает реальное распараллеливание вычислений.

## 8. Conclusions

Во время данной работы были реализованы и протестированы два вида алгоритма поиска минимального значения целочисленного вектора, а именно последовательная SEQ и параллельная с использованием MPI.

Оба алгоритма проходят функциональные тесты, которые подтверждают корректность вычисления минимума используя разных типов входых данных

Тесты на производительность показывают что выбранный алгоритм с линейной сложностью без ошибок обрабатывает большие объемы данных, MPI‑версия интегрирована в общую инфраструктуру курса и использует распределение данных по процессам для эффективного распараллеливания.

## 9. References

1. Документация курса: `https://learning-process.github.io/parallel_programming_course/ru`
2. Страница репозитория курса: <https://github.com/learning-process/ppc-2025-processes-engineers>
3. Стандартная библиотека C++ (`<algorithm>`, `std::min_element`) – документация C++.
