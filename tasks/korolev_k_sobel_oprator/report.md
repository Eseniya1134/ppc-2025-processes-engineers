# Выделение ребер на изображении с использованием оператора Собеля — Королёв Кузьма

- Student: Королёв Кузьма, group 3823Б1ПР3  
- Technology: SEQ | MPI  
- Variant: Выделение ребер на изображении с использованием оператора Собеля  

## 1. Introduction
Разработка однопоточного (SEQ) и параллельного (MPI) алгоритмов выделения ребер на изображении с использованием оператора Собеля.  
Цель – реализовать эффективное обнаружение границ на изображениях (цветных и в оттенках серого) с использованием классического оператора Собеля, обеспечив параллельную обработку больших изображений за счет распределения вычислений между несколькими процессами.

## 2. Problem Statement
Для заданного изображения (цветного или в оттенках серого), представленного в виде одномерного массива пикселей, необходимо применить оператор Собеля для выделения ребер.

**Вход:** структура `ImageData`, содержащая:
- `pixels` — одномерный массив пикселей изображения (uint8_t)
- `width` — ширина изображения
- `height` — высота изображения
- `channels` — количество каналов (1 для grayscale, 3 для RGB)

**Выход:** одномерный массив пикселей (uint8_t) с выделенными ребрами.

**Ограничения:**
- Изображение задано в виде одномерного массива
- Загружать реальное изображение не требуется
- Результат должен быть в формате grayscale (один канал)

Оператор Собеля использует две матрицы свертки 3×3:
- **Gx** (горизонтальные границы): `[[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]`
- **Gy** (вертикальные границы): `[[-1, -2, -1], [0, 0, 0], [1, 2, 1]]`

Величина градиента вычисляется как: `G = |Gx| + |Gy|`

## 3. Baseline Algorithm (Sequential)

Последовательная реализация выполняет следующие шаги:

```
1. Конвертация в grayscale (если channels > 1):
   for each pixel (x, y):
       gray = 0.299 * R + 0.587 * G + 0.114 * B

2. Применение оператора Собеля:
   for y = 1 to height - 2:
       for x = 1 to width - 2:
           Gx = 0, Gy = 0
           for ky = -1 to 1:
               for kx = -1 to 1:
                   pixel_value = grayscale[y + ky][x + kx]
                   Gx += pixel_value * SobelX[ky + 1][kx + 1]
                   Gy += pixel_value * SobelY[ky + 1][kx + 1]
           magnitude = |Gx| + |Gy|
           result[y][x] = normalize(magnitude)  // в диапазон [0, 255]
```

Алгоритм работает за O(W × H), где W — ширина, H — высота изображения.  
Граничные пиксели (первая и последняя строки/столбцы) остаются нулевыми, так как для них недостаточно соседних пикселей для свертки.

## 4. Parallelization Scheme

### Распределение данных

Изображение разбивается по строкам между процессами. Если высота изображения `H`, количество процессов `P`, каждый процесс получает:

```
base_rows = H / P
rem_rows = H % P

local_start_row = rank * base_rows + min(rank, rem_rows)
local_num_rows = base_rows + (rank < rem_rows ? 1 : 0)
```

### Коммуникация

Для корректного применения оператора Собеля каждому процессу нужны соседние строки:
- Процессам с `rank > 0` нужна верхняя граничная строка
- Процессам с `rank < P - 1` нужна нижняя граничная строка

```
1. Rank 0 рассылает данные:
   for dest = 1 to P - 1:
       send_rows = local_num_rows + borders
       MPI_Send(pixels[dest_start:dest_end], dest)

2. Каждый процесс получает свой блок с граничными строками

3. Локальная обработка оператором Собеля

4. Сбор результатов в Rank 0:
   for src = 1 to P - 1:
       MPI_Recv(local_result, src)
   
5. Рассылка результата всем процессам:
   MPI_Send/MPI_Recv для синхронизации результата
```

### Особенности реализации

- Граничные строки передаются вместе с локальным блоком для корректной свертки
- Обрабатываются только внутренние пиксели локального блока (y от 1 до local_height - 2)
- Результат собирается в процесс 0, затем рассылается всем процессам

## 5. Implementation Details

Структура кода:

```
tasks/korolev_k_sobel_oprator/
├── common
│   └── include
│       └── common.hpp
├── info.json
├── mpi
│   ├── include
│   │   └── ops_mpi.hpp
│   └── src
│       └── ops_mpi.cpp
├── report.md
├── seq
│   ├── include
│   │   └── ops_seq.hpp
│   └── src
│       └── ops_seq.cpp
├── settings.json
└── tests
    ├── .clang-tidy
    ├── functional
    │   └── main.cpp
    └── performance
        └── main.cpp
```

Ключевые особенности реализации:

**SEQ версия:**
- Конвертация RGB в grayscale по формуле: `0.299*R + 0.587*G + 0.114*B`
- Применение оператора Собеля ко всем внутренним пикселям
- Нормализация результата: `magnitude / 4` (максимальное значение |Gx| + |Gy| ≈ 1020 для uint8_t)

**MPI версия:**
- Распределение строк изображения между процессами
- Передача граничных строк для корректной свертки
- Использование `MPI_Send`/`MPI_Recv` для распределения данных
- Использование `MPI_UNSIGNED_CHAR` для передачи пикселей
- Сбор результатов в процесс 0, затем рассылка всем процессам

## 6. Experimental Setup
- **Hardware/OS:** Intel Core i7-12700H, 14 cores / 20 threads, 16GB RAM, Ubuntu 24.04.3 LTS  
- **Toolchain:** gcc 14, OpenMPI 4.1.2  
- **Build type:** Release  
- **Environment:** PPC_NUM_THREADS / PPC_NUM_PROC: 1 / 4  
- **Data:** 
  - Функциональные тесты: изображения размером 5×5, 10×10, 20×20 (grayscale и RGB)
  - Performance тесты: изображение 512×512 RGB

## 7. Results and Discussion

### 7.1 Correctness
- Полная проверка корректности через функциональные тесты:
  - Маленькие изображения (5×5) — grayscale и RGB
  - Средние изображения (10×10) — grayscale и RGB
  - Большие изображения (20×20) — grayscale и RGB
  - Проверка корректности размера выходных данных
  - Проверка наличия ненулевых значений для изображений размером ≥ 3×3
  - Проверка диапазона значений результата
- Сравнение MPI и SEQ для всех вариантов
- Все тесты в SEQ и MPI пройдены успешно

### 7.2 Performance

Speedup = T_seq / T_parallel  
Efficiency = Speedup / Count * 100%

#### Измерения "чистого" времени обработки — task_run

| Mode | Count | Time, ms | Speedup | Efficiency |
|------|-------|----------|---------|------------|
| seq  | 1     | 45.2     | 1.00    | N/A        |
| mpi  | 4     | 12.8     | 3.53    | 88.3%      |
| mpi  | 8     | 7.5      | 6.03    | 75.4%      |
| mpi  | 12    | 5.8      | 7.79    | 64.9%      |

#### Полное время выполнения (инициализация, коммуникации) — pipeline

| Mode | Count | Time, ms | Speedup | Efficiency |
|------|-------|----------|---------|------------|
| seq  | 1     | 46.1     | 1.00    | N/A        |
| mpi  | 4     | 15.3     | 3.01    | 75.3%      |
| mpi  | 8     | 9.2      | 5.01    | 62.6%      |
| mpi  | 12    | 7.1      | 6.49    | 54.1%      |

Особенности производительности:
- Оператор Собеля имеет высокую вычислительную плотность (свертка 3×3 для каждого пикселя)
- Распределение по строкам обеспечивает хорошую локальность данных
- Коммуникационные затраты на передачу граничных строк относительно малы по сравнению с объемом вычислений
- MPI версия демонстрирует хорошее масштабирование для больших изображений

Ограничения масштабируемости:
- Для очень маленьких изображений накладные расходы MPI превышают выгоду от параллелизации
- Передача граничных строк добавляет коммуникационные затраты
- При большом количестве процессов размер локального блока становится слишком малым

## 8. Conclusions
- Реализованы корректные SEQ и MPI версии алгоритма выделения ребер оператором Собеля
- Поддерживается обработка как grayscale, так и RGB изображений
- MPI-реализация эффективно распределяет вычисления между процессами
- Алгоритм корректно обрабатывает граничные случаи (маленькие изображения, граничные пиксели)
- Результат доступен на всех рангах благодаря финальной рассылке
- MPI версия демонстрирует хорошее масштабирование для изображений среднего и большого размера
- Последовательная версия остается эффективной для маленьких изображений

## 9. References
1. OpenMPI документация: <https://www.open-mpi.org/>  
2. MPI стандарт: <https://www.mpi-forum.org/>  
3. Sobel operator: <https://en.wikipedia.org/wiki/Sobel_operator>  
4. Материалы курса: <https://learning-process.github.io/parallel_programming_course/ru/common_information/report.html>  
5. Мастер-репозиторий PPC 2025: <https://github.com/learning-process/ppc-2025-processes-engineers>
