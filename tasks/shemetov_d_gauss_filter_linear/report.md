# Линейная фильтрация изображений (вертикальное разбиение). Ядро Гаусса 3x3

- **Студент**: Шеметов Даниил Олегович, группа 3823Б1ПР3
- **Технологии**: SEQ | MPI
- **Вариант**: 28

## 1. Введение

- **Линейная фильтрация** изображений является одной из базовых операций цифровой обработки изображений. Она применяется для сглаживания, подавления шума и предварительной обработки данных перед сложными алгоритмами анализа изображений. 

- **Фильтр Гаусса** - один из наиболее распространённых линейных фильтров, обладающий хорошими сглаживающими свойствами и устойчивостью к шуму.

## 2. Постановка проблемы

**Цель работы** — реализовать алгоритм линейной фильтрации изображения с ядром Гаусса 3×3 в последовательной (SEQ) и параллельной (MPI) версиях, а также проверить корректность и сравнить производительность этих реализаций.

## 3. Постановка задачи

### 3.1. Формальная постановка

Пусть задано изображение `I` размером `width × height`, представленное в виде двумерного массива пикселей типа `uint8_t`. Для этого была реализована струткутура:
- *Псевдокод:*
```
Pixel {
   red   channel
   green channel
   blue  channel
}
```
Требуется применить к изображению линейный фильтр с ядром Гаусса 3×3 и получить выходное изображение `O` того же размера.

### 3.2. Входные данные

- Изображение в виде `std::vector<std::vector<Pixel>>`
- Размеры изображения: `width`, `height`

### 3.3. Выходные данные

- Отфильтрованное изображение типа `std::vector<std::vector<Pixel>>` того же размера

### 3.4. Ядро Гаусса 3×3

```
           |1 2 1|
K = 1/16 * |2 4 2|
           |1 2 1|
```

### 3.5. Особенности обработки

- Для каждого пикселя вычисляется взвешенная сумма значений соседних пикселей в окне 3×3
- Граничные пиксели не обрабатываются
```
X X X X X
X O O O X
X O O O X
X O O O X
X X X X X
```
- Результат ограничивается диапазоном `[0, 255]`

## 4. Последовательная реализация (SEQ)

### 4.1. Этапы выполнения

**4.1.1. **Валидация данных (`ValidationImpl`)**
   - Проверка, что входное изображение не пустое и имеет корректные размеры

**4.1.2. **Предобработка (`PreProcessingImpl`)**
   - Дополнительная подготовка данных не требуется

**4.1.3. **Основные вычисления (`RunImpl`)**
   - Проверка минимального размера изображения (не менее 3×3)
   - Последовательный обход изображения и применение ядра Гаусса 3×3 к каждому пикселю
   - Ограничение результата диапазоном `[0, 255]`

4. **Постобработка (`PostProcessingImpl`)**
   - Дополнительная подготовка данных не требуется

### 4.2. Псевдокод последовательного алгоритма

```
for i = 1 to height - 1:
   for j = 1 to width - 1:
      red   = 0.F;
      green = 0.F;
      blue  = 0.F;
      for ki = -1 to 1:
         for kj = -1 to 1:
            &lnk_pixel = in[i + ki][j + kj];
            coefficient = kernel[ki + 1][kj + 1];
      
            red   += coefficient * lnk_pixel.red;
            green += coefficient * lnk_pixel.green;
            blue  += coefficient * lnk_pixel.blue;

      output[i][j] = clamp(red,    0.F, 255.F)
      output[i][j] = clamp(green,  0.F, 255.F)
      output[i][j] = clamp(blue,   0.F, 255.F)
```

### 4.3. Сложность алгоритма

| Характеристика            | Значение |
|---------------------------|----------|
| Временная сложность       | O(width × height) |
| Пространственная сложность| O(width × height) |

## 5. Параллельная реализация (MPI)

### 5.1. Стратегия распараллеливания

Используется **вертикальное разбиение изображения по строкам**:

- Каждому процессу MPI назначается *непрерывный диапазон строк*
- Каждый процесс вычисляет фильтр *только для своей части изображения*
- Результаты вычислений *собираются* на процессе с *0*

### 5.2. Алгоритм параллельной реализации

**5.2.1. Получение номера процесса (`rank`) с помощью `MPI_Comm_rank`
**5.2.2. Получение общего количества процессов (`size`) с помощью `MPI_Comm_size`
**5.2.3. Вычисление количества строк, обрабатываемых *каждым процессом*
**5.2.4. Локальная фильтрация изображения в *пределах выделенного диапазона*
**5.2.5. Сбор результатов всех процессов с использованием `MPI_Gatherv`

### 5.3. Псевдокод MPI-алгоритма

```
rank = MPI_Comm_rank()
size = MPI_Comm_size()

block_size = height / size
extra_rows = height % size

start_row = rank * block_size + min(rank, extra)
local_rows = base_rows + ((rank < extra_rows) ? 1 : 0);

for i = 0; i < local_rows; ++i:
    for j = 1; j < width - 1; ++j:
         red   = 0.F;
         green = 0.F;
         blue  = 0.F;
         for ki = -1 to 1:
            for kj = -1 to 1:
               &lnk_pixel = in[i + ki][j + kj];
               coefficient = kernel[ki + 1][kj + 1];

               red   += coefficient * lnk_pixel.red;
               green += coefficient * lnk_pixel.green;
               blue  += coefficient * lnk_pixel.blue;

         local_out[i][j] = clamp(red,    0.F, 255.F)
         local_out[i][j] = clamp(green,  0.F, 255.F)
         local_out[i][j] = clamp(blue,   0.F, 255.F)

MPI_Allreduce(local_out, global_out, MPI_MAX)
```

### 5.4. Коммуникации MPI

- `MPI_Comm_rank`, `MPI_Comm_size` — получение информации о процессах
- `MPI_Gatherv` — сбор вычисленных блоков изображения на процессе 0

### 5.5. Сложность параллельного алгоритма

| Характеристика            | Значение |
|---------------------------|----------|
| Временная сложность       | O((width × height) / size + коммуникации) |
| Пространственная сложность| O(width × height) |

где `size` — количество MPI-процессов.

## 6. Экспериментальные результаты

### 6.1. Функциональные тесты

Реализованы функциональные тесты для:
- Малых синтетических изображений
- Реальных изображений, загружаемых из файла

Результаты последовательной и параллельной версий совпадают.

### 6.2. Тесты производительности

Тесты производительности выполняются на изображениях размером 1024×1024 пикселей. Измеренные (в миллисекундах) првиедены для режимов `pipeline` и `task_run`.

| Режим               | SEQ, ms | MPI (4 процесса), ms  | MPI (2 процесса), ms  | MPI (1 процесс), ms   |
|---------------------|--------:|----------------------:|----------------------:|----------------------:|
| Full cycle          | 221     | 95                    | 153                   | 266                   |
| Run only            | 229     | 102                   | 150                   | 268                   |
| Small image         | 1       | 0                     | 0                     | 0                     |
| Large image         | 231     | 104                   | 158                   | 266                   |
| Large RGB image     | 892     | 447                   | 642                   | 1102                  |

## 7. Анализ результатов

- Реализация корректна и проходит все функциональные тесты
- MPI-версия демонстрирует ускорение по сравнению с SEQ при увеличении размера изображения
- Основные накладные расходы связаны со сбором данных и затратами на коммуникации MPI
- Вертикальное разбиаене равномерно загружает процессы

## 8. Выводы

- **8.1. Реализованы последовательная (SEQ) и параллельная (MPI) версии линейной фильтрации изображения с использованием ядра Гаусса 3×3
- **8.2. Алгоритмы корректно обрабатывают изображения различных размеров
- **8.3. MPI-версия позволяет ускорить вычисления при достаточном размере изображения
- **8.4. Полученные результаты подтверждают корректность и работоспособность реализации

## 9. Приложение

### Приложение A — Последовательная реализация
См. файл `seq/src/ops_seq.cpp`

### Приложение B — Параллельная реализация
См. файл `mpi/src/ops_mpi.cpp`
